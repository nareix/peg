package main

// Code generated by ./peg -inline -switch peg.peg DO NOT EDIT.

import (
	"fmt"
	"github.com/pointlander/peg/tree"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint32

const (
	ruleUnknown pegRule = iota
	ruleGrammar
	ruleImport
	ruleSingleImport
	ruleMultiImport
	ruleImportName
	ruleDefinition
	ruleExpression
	ruleSequence
	rulePrefix
	ruleSuffix
	rulePrimary
	ruleIdentifier
	ruleIdentStart
	ruleIdentCont
	ruleLiteral
	ruleClass
	ruleRanges
	ruleDoubleRanges
	ruleRange
	ruleDoubleRange
	ruleChar
	ruleDoubleChar
	ruleEscape
	ruleLeftArrow
	ruleSlash
	ruleAnd
	ruleNot
	ruleQuestion
	ruleStar
	rulePlus
	ruleOpen
	ruleClose
	ruleDot
	ruleSpaceComment
	ruleSpacing
	ruleMustSpacing
	ruleComment
	ruleSpace
	ruleEndOfLine
	ruleEndOfFile
	ruleAction
	ruleActionBody
	ruleBegin
	ruleEnd
	ruleAction0
	ruleAction1
	ruleAction2
	rulePegText
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48

	nrRule
)

var rul3s = [...]string{
	"Unknown",
	"Grammar",
	"Import",
	"SingleImport",
	"MultiImport",
	"ImportName",
	"Definition",
	"Expression",
	"Sequence",
	"Prefix",
	"Suffix",
	"Primary",
	"Identifier",
	"IdentStart",
	"IdentCont",
	"Literal",
	"Class",
	"Ranges",
	"DoubleRanges",
	"Range",
	"DoubleRange",
	"Char",
	"DoubleChar",
	"Escape",
	"LeftArrow",
	"Slash",
	"And",
	"Not",
	"Question",
	"Star",
	"Plus",
	"Open",
	"Close",
	"Dot",
	"SpaceComment",
	"Spacing",
	"MustSpacing",
	"Comment",
	"Space",
	"EndOfLine",
	"EndOfFile",
	"Action",
	"ActionBody",
	"Begin",
	"End",
	"Action0",
	"Action1",
	"Action2",
	"PegText",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Peg struct {
	*tree.Tree

	Buffer string
	buffer []rune
	rules  [95]func() bool
	action func(pegRule)
	Pretty bool
	max    token32
	tokens32
	position   uint32
	tokenIndex uint32
}

var ErrSyntax = fmt.Errorf("syntax error")

func (p *Peg) Parse(rule ...int) error {
	r := 1
	if len(rule) > 0 {
		r = rule[0]
	}
	matches := p.rules[r]()
	if matches {
		p.Trim(p.tokenIndex)
		return nil
	}
	return ErrSyntax
}

func (p *Peg) Reset() {
	p.max = token32{}
	p.position = 0
	p.tokenIndex = 0

	p.buffer = []rune(p.Buffer)
	if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
		p.buffer = append(p.buffer, endSymbol)
	}
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}
	for ; j < length; j++ {
		translations[positions[j]] = textPosition{line, symbol}
	}

	return translations
}

func (p *Peg) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Peg) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Peg) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *Peg) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddPackage(text)
		case ruleAction1:
			p.AddPeg(text)
		case ruleAction2:
			p.AddState(text)
		case ruleAction3:
			p.AddImport(text)
		case ruleAction4:
			p.AddRule(text)
		case ruleAction5:
			p.AddExpression()
		case ruleAction6:
			p.AddAlternate()
		case ruleAction7:
			p.AddNil()
			p.AddAlternate()
		case ruleAction8:
			p.AddNil()
		case ruleAction9:
			p.AddSequence()
		case ruleAction10:
			p.AddPredicate(text)
		case ruleAction11:
			p.AddStateChange(text)
		case ruleAction12:
			p.AddPeekFor()
		case ruleAction13:
			p.AddPeekNot()
		case ruleAction14:
			p.AddQuery()
		case ruleAction15:
			p.AddStar()
		case ruleAction16:
			p.AddPlus()
		case ruleAction17:
			p.AddName(text)
		case ruleAction18:
			p.AddDot()
		case ruleAction19:
			p.AddAction(text)
		case ruleAction20:
			p.AddPush()
		case ruleAction21:
			p.AddSequence()
		case ruleAction22:
			p.AddSequence()
		case ruleAction23:
			p.AddPeekNot()
			p.AddDot()
			p.AddSequence()
		case ruleAction24:
			p.AddPeekNot()
			p.AddDot()
			p.AddSequence()
		case ruleAction25:
			p.AddAlternate()
		case ruleAction26:
			p.AddAlternate()
		case ruleAction27:
			p.AddRange()
		case ruleAction28:
			p.AddDoubleRange()
		case ruleAction29:
			p.AddCharacter(text)
		case ruleAction30:
			p.AddDoubleCharacter(text)
		case ruleAction31:
			p.AddCharacter(text)
		case ruleAction32:
			p.AddCharacter("\a")
		case ruleAction33:
			p.AddCharacter("\b")
		case ruleAction34:
			p.AddCharacter("\x1B")
		case ruleAction35:
			p.AddCharacter("\f")
		case ruleAction36:
			p.AddCharacter("\n")
		case ruleAction37:
			p.AddCharacter("\r")
		case ruleAction38:
			p.AddCharacter("\t")
		case ruleAction39:
			p.AddCharacter("\v")
		case ruleAction40:
			p.AddCharacter("'")
		case ruleAction41:
			p.AddCharacter("\"")
		case ruleAction42:
			p.AddCharacter("[")
		case ruleAction43:
			p.AddCharacter("]")
		case ruleAction44:
			p.AddCharacter("-")
		case ruleAction45:
			p.AddHexaCharacter(text)
		case ruleAction46:
			p.AddOctalCharacter(text)
		case ruleAction47:
			p.AddOctalCharacter(text)
		case ruleAction48:
			p.AddCharacter("\\")

		}
		if p.action != nil {
			p.action(token.pegRule)
		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*Peg) error {
	return func(p *Peg) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Peg) error {
	return func(p *Peg) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Peg) add(rule pegRule, begin uint32) {
	p.tokens32.Add(rule, begin, p.position, p.tokenIndex)
	p.tokenIndex++
	if begin != p.position && p.position > p.max.end {
		p.max = token32{rule, begin, p.position}
	}
}

func (p *Peg) matchDot() bool {
	if p.buffer[p.position] != endSymbol {
		p.position++
		return true
	}
	return false
}

func (p *Peg) matchChar(c rune) bool {
	if p.buffer[p.position] == c {
		p.position++
		return true
	}
	return false
}

func (p *Peg) matchRange(lower rune, upper rune) bool {
	if c := p.buffer[p.position]; c >= lower && c <= upper {
		p.position++
		return true
	}
	return false
}

func (p *Peg) Init(options ...func(*Peg) error) error {
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.Reset()

	p.rules = [...]func() bool{
		nil,
		/* 0 Grammar <- <(Spacing ('p' 'a' 'c' 'k' 'a' 'g' 'e') MustSpacing Identifier Action0 Import* ('t' 'y' 'p' 'e') MustSpacing Identifier Action1 ('P' 'e' 'g') Spacing Action Action2 Definition+ EndOfFile)> */
		func() bool {
			position0, tokenIndex0 := p.position, p.tokenIndex
			{
				position1 := p.position
				if !p.rules[ruleSpacing]() {
					goto l0
				}
				if p.buffer[p.position] != rune('p') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('a') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('c') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('k') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('a') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('g') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('e') {
					goto l0
				}
				p.position++
				if !p.rules[ruleMustSpacing]() {
					goto l0
				}
				if !p.rules[ruleIdentifier]() {
					goto l0
				}
				{
					p.add(ruleAction0, p.position)
				}
			l3:
				{
					position4, tokenIndex4 := p.position, p.tokenIndex
					{
						position5 := p.position
						if p.buffer[p.position] != rune('i') {
							goto l4
						}
						p.position++
						if p.buffer[p.position] != rune('m') {
							goto l4
						}
						p.position++
						if p.buffer[p.position] != rune('p') {
							goto l4
						}
						p.position++
						if p.buffer[p.position] != rune('o') {
							goto l4
						}
						p.position++
						if p.buffer[p.position] != rune('r') {
							goto l4
						}
						p.position++
						if p.buffer[p.position] != rune('t') {
							goto l4
						}
						p.position++
						if !p.rules[ruleSpacing]() {
							goto l4
						}
						{
							position6, tokenIndex6 := p.position, p.tokenIndex
							{
								position8 := p.position
								if p.buffer[p.position] != rune('(') {
									goto l7
								}
								p.position++
								if !p.rules[ruleSpacing]() {
									goto l7
								}
							l9:
								{
									position10, tokenIndex10 := p.position, p.tokenIndex
									if !p.rules[ruleImportName]() {
										goto l10
									}
									if p.buffer[p.position] != rune('\n') {
										goto l10
									}
									p.position++
									if !p.rules[ruleSpacing]() {
										goto l10
									}
									goto l9
								l10:
									p.position, p.tokenIndex = position10, tokenIndex10
								}
								if !p.rules[ruleSpacing]() {
									goto l7
								}
								if p.buffer[p.position] != rune(')') {
									goto l7
								}
								p.position++
								p.add(ruleMultiImport, position8)
							}
							goto l6
						l7:
							p.position, p.tokenIndex = position6, tokenIndex6
							{
								position11 := p.position
								if !p.rules[ruleImportName]() {
									goto l4
								}
								p.add(ruleSingleImport, position11)
							}
						}
					l6:
						if !p.rules[ruleSpacing]() {
							goto l4
						}
						p.add(ruleImport, position5)
					}
					goto l3
				l4:
					p.position, p.tokenIndex = position4, tokenIndex4
				}
				if p.buffer[p.position] != rune('t') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('y') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('p') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('e') {
					goto l0
				}
				p.position++
				if !p.rules[ruleMustSpacing]() {
					goto l0
				}
				if !p.rules[ruleIdentifier]() {
					goto l0
				}
				{
					p.add(ruleAction1, p.position)
				}
				if p.buffer[p.position] != rune('P') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('e') {
					goto l0
				}
				p.position++
				if p.buffer[p.position] != rune('g') {
					goto l0
				}
				p.position++
				if !p.rules[ruleSpacing]() {
					goto l0
				}
				if !p.rules[ruleAction]() {
					goto l0
				}
				{
					p.add(ruleAction2, p.position)
				}
				{
					position16 := p.position
					if !p.rules[ruleIdentifier]() {
						goto l0
					}
					{
						p.add(ruleAction4, p.position)
					}
					if !p.rules[ruleLeftArrow]() {
						goto l0
					}
					if !p.rules[ruleExpression]() {
						goto l0
					}
					{
						p.add(ruleAction5, p.position)
					}
					{
						position19, tokenIndex19 := p.position, p.tokenIndex
						{
							position20, tokenIndex20 := p.position, p.tokenIndex
							if !p.rules[ruleIdentifier]() {
								goto l21
							}
							if !p.rules[ruleLeftArrow]() {
								goto l21
							}
							goto l20
						l21:
							p.position, p.tokenIndex = position20, tokenIndex20
							{
								position22, tokenIndex22 := p.position, p.tokenIndex
								if !p.matchDot() {
									goto l22
								}
								goto l0
							l22:
								p.position, p.tokenIndex = position22, tokenIndex22
							}
						}
					l20:
						p.position, p.tokenIndex = position19, tokenIndex19
					}
					p.add(ruleDefinition, position16)
				}
			l14:
				{
					position15, tokenIndex15 := p.position, p.tokenIndex
					{
						position23 := p.position
						if !p.rules[ruleIdentifier]() {
							goto l15
						}
						{
							p.add(ruleAction4, p.position)
						}
						if !p.rules[ruleLeftArrow]() {
							goto l15
						}
						if !p.rules[ruleExpression]() {
							goto l15
						}
						{
							p.add(ruleAction5, p.position)
						}
						{
							position26, tokenIndex26 := p.position, p.tokenIndex
							{
								position27, tokenIndex27 := p.position, p.tokenIndex
								if !p.rules[ruleIdentifier]() {
									goto l28
								}
								if !p.rules[ruleLeftArrow]() {
									goto l28
								}
								goto l27
							l28:
								p.position, p.tokenIndex = position27, tokenIndex27
								{
									position29, tokenIndex29 := p.position, p.tokenIndex
									if !p.matchDot() {
										goto l29
									}
									goto l15
								l29:
									p.position, p.tokenIndex = position29, tokenIndex29
								}
							}
						l27:
							p.position, p.tokenIndex = position26, tokenIndex26
						}
						p.add(ruleDefinition, position23)
					}
					goto l14
				l15:
					p.position, p.tokenIndex = position15, tokenIndex15
				}
				{
					position30 := p.position
					{
						position31, tokenIndex31 := p.position, p.tokenIndex
						if !p.matchDot() {
							goto l31
						}
						goto l0
					l31:
						p.position, p.tokenIndex = position31, tokenIndex31
					}
					p.add(ruleEndOfFile, position30)
				}
				p.add(ruleGrammar, position1)
			}
			return true
		l0:
			p.position, p.tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Import <- <('i' 'm' 'p' 'o' 'r' 't' Spacing (MultiImport / SingleImport) Spacing)> */
		nil,
		/* 2 SingleImport <- <ImportName> */
		nil,
		/* 3 MultiImport <- <('(' Spacing (ImportName '\n' Spacing)* Spacing ')')> */
		nil,
		/* 4 ImportName <- <('"' <((&('-') '-') | (&('.') '.') | (&('/') '/') | (&('_') '_') | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))+> '"' Action3)> */
		func() bool {
			position35, tokenIndex35 := p.position, p.tokenIndex
			{
				position36 := p.position
				if p.buffer[p.position] != rune('"') {
					goto l35
				}
				p.position++
				{
					position37 := p.position
					{
						switch p.buffer[p.position] {
						case '-':
							if p.buffer[p.position] != rune('-') {
								goto l35
							}
							p.position++
						case '.':
							if p.buffer[p.position] != rune('.') {
								goto l35
							}
							p.position++
						case '/':
							if p.buffer[p.position] != rune('/') {
								goto l35
							}
							p.position++
						case '_':
							if p.buffer[p.position] != rune('_') {
								goto l35
							}
							p.position++
						case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
							if c := p.buffer[p.position]; c < rune('A') || c > rune('Z') {
								goto l35
							}
							p.position++
						case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
							if c := p.buffer[p.position]; c < rune('0') || c > rune('9') {
								goto l35
							}
							p.position++
						default:
							if c := p.buffer[p.position]; c < rune('a') || c > rune('z') {
								goto l35
							}
							p.position++
						}
					}

				l38:
					{
						position39, tokenIndex39 := p.position, p.tokenIndex
						{
							switch p.buffer[p.position] {
							case '-':
								if p.buffer[p.position] != rune('-') {
									goto l39
								}
								p.position++
							case '.':
								if p.buffer[p.position] != rune('.') {
									goto l39
								}
								p.position++
							case '/':
								if p.buffer[p.position] != rune('/') {
									goto l39
								}
								p.position++
							case '_':
								if p.buffer[p.position] != rune('_') {
									goto l39
								}
								p.position++
							case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
								if c := p.buffer[p.position]; c < rune('A') || c > rune('Z') {
									goto l39
								}
								p.position++
							case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
								if c := p.buffer[p.position]; c < rune('0') || c > rune('9') {
									goto l39
								}
								p.position++
							default:
								if c := p.buffer[p.position]; c < rune('a') || c > rune('z') {
									goto l39
								}
								p.position++
							}
						}

						goto l38
					l39:
						p.position, p.tokenIndex = position39, tokenIndex39
					}
					p.add(rulePegText, position37)
				}
				if p.buffer[p.position] != rune('"') {
					goto l35
				}
				p.position++
				{
					p.add(ruleAction3, p.position)
				}
				p.add(ruleImportName, position36)
			}
			return true
		l35:
			p.position, p.tokenIndex = position35, tokenIndex35
			return false
		},
		/* 5 Definition <- <(Identifier Action4 LeftArrow Expression Action5 &((Identifier LeftArrow) / !.))> */
		nil,
		/* 6 Expression <- <((Sequence (Slash Sequence Action6)* (Slash Action7)?) / Action8)> */
		func() bool {
			{
				position45 := p.position
				{
					position46, tokenIndex46 := p.position, p.tokenIndex
					if !p.rules[ruleSequence]() {
						goto l47
					}
				l48:
					{
						position49, tokenIndex49 := p.position, p.tokenIndex
						if !p.rules[ruleSlash]() {
							goto l49
						}
						if !p.rules[ruleSequence]() {
							goto l49
						}
						{
							p.add(ruleAction6, p.position)
						}
						goto l48
					l49:
						p.position, p.tokenIndex = position49, tokenIndex49
					}
					{
						position51, tokenIndex51 := p.position, p.tokenIndex
						if !p.rules[ruleSlash]() {
							goto l51
						}
						{
							p.add(ruleAction7, p.position)
						}
						goto l52
					l51:
						p.position, p.tokenIndex = position51, tokenIndex51
					}
				l52:
					goto l46
				l47:
					p.position, p.tokenIndex = position46, tokenIndex46
					{
						p.add(ruleAction8, p.position)
					}
				}
			l46:
				p.add(ruleExpression, position45)
			}
			return true
		},
		/* 7 Sequence <- <(Prefix (Prefix Action9)*)> */
		func() bool {
			position55, tokenIndex55 := p.position, p.tokenIndex
			{
				position56 := p.position
				if !p.rules[rulePrefix]() {
					goto l55
				}
			l57:
				{
					position58, tokenIndex58 := p.position, p.tokenIndex
					if !p.rules[rulePrefix]() {
						goto l58
					}
					{
						p.add(ruleAction9, p.position)
					}
					goto l57
				l58:
					p.position, p.tokenIndex = position58, tokenIndex58
				}
				p.add(ruleSequence, position56)
			}
			return true
		l55:
			p.position, p.tokenIndex = position55, tokenIndex55
			return false
		},
		/* 8 Prefix <- <((And Action Action10) / (Not Action Action11) / ((&('!') (Not Suffix Action13)) | (&('&') (And Suffix Action12)) | (&('"' | '\'' | '(' | '.' | '<' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{') Suffix)))> */
		func() bool {
			position60, tokenIndex60 := p.position, p.tokenIndex
			{
				position61 := p.position
				{
					position62, tokenIndex62 := p.position, p.tokenIndex
					if !p.rules[ruleAnd]() {
						goto l63
					}
					if !p.rules[ruleAction]() {
						goto l63
					}
					{
						p.add(ruleAction10, p.position)
					}
					goto l62
				l63:
					p.position, p.tokenIndex = position62, tokenIndex62
					if !p.rules[ruleNot]() {
						goto l65
					}
					if !p.rules[ruleAction]() {
						goto l65
					}
					{
						p.add(ruleAction11, p.position)
					}
					goto l62
				l65:
					p.position, p.tokenIndex = position62, tokenIndex62
					{
						switch p.buffer[p.position] {
						case '!':
							if !p.rules[ruleNot]() {
								goto l60
							}
							if !p.rules[ruleSuffix]() {
								goto l60
							}
							{
								p.add(ruleAction13, p.position)
							}
						case '&':
							if !p.rules[ruleAnd]() {
								goto l60
							}
							if !p.rules[ruleSuffix]() {
								goto l60
							}
							{
								p.add(ruleAction12, p.position)
							}
						default:
							if !p.rules[ruleSuffix]() {
								goto l60
							}
						}
					}

				}
			l62:
				p.add(rulePrefix, position61)
			}
			return true
		l60:
			p.position, p.tokenIndex = position60, tokenIndex60
			return false
		},
		/* 9 Suffix <- <(Primary ((&('+') (Plus Action16)) | (&('*') (Star Action15)) | (&('?') (Question Action14)))?)> */
		func() bool {
			position70, tokenIndex70 := p.position, p.tokenIndex
			{
				position71 := p.position
				{
					position72 := p.position
					{
						switch p.buffer[p.position] {
						case '<':
							{
								position74 := p.position
								if p.buffer[p.position] != rune('<') {
									goto l70
								}
								p.position++
								if !p.rules[ruleSpacing]() {
									goto l70
								}
								p.add(ruleBegin, position74)
							}
							if !p.rules[ruleExpression]() {
								goto l70
							}
							{
								position75 := p.position
								if p.buffer[p.position] != rune('>') {
									goto l70
								}
								p.position++
								if !p.rules[ruleSpacing]() {
									goto l70
								}
								p.add(ruleEnd, position75)
							}
							{
								p.add(ruleAction20, p.position)
							}
						case '{':
							if !p.rules[ruleAction]() {
								goto l70
							}
							{
								p.add(ruleAction19, p.position)
							}
						case '.':
							{
								position78 := p.position
								if p.buffer[p.position] != rune('.') {
									goto l70
								}
								p.position++
								if !p.rules[ruleSpacing]() {
									goto l70
								}
								p.add(ruleDot, position78)
							}
							{
								p.add(ruleAction18, p.position)
							}
						case '[':
							{
								position80 := p.position
								{
									position81, tokenIndex81 := p.position, p.tokenIndex
									if p.buffer[p.position] != rune('[') {
										goto l82
									}
									p.position++
									if p.buffer[p.position] != rune('[') {
										goto l82
									}
									p.position++
									{
										position83, tokenIndex83 := p.position, p.tokenIndex
										{
											position85, tokenIndex85 := p.position, p.tokenIndex
											if p.buffer[p.position] != rune('^') {
												goto l86
											}
											p.position++
											if !p.rules[ruleDoubleRanges]() {
												goto l86
											}
											{
												p.add(ruleAction23, p.position)
											}
											goto l85
										l86:
											p.position, p.tokenIndex = position85, tokenIndex85
											if !p.rules[ruleDoubleRanges]() {
												goto l83
											}
										}
									l85:
										goto l84
									l83:
										p.position, p.tokenIndex = position83, tokenIndex83
									}
								l84:
									if p.buffer[p.position] != rune(']') {
										goto l82
									}
									p.position++
									if p.buffer[p.position] != rune(']') {
										goto l82
									}
									p.position++
									goto l81
								l82:
									p.position, p.tokenIndex = position81, tokenIndex81
									if p.buffer[p.position] != rune('[') {
										goto l70
									}
									p.position++
									{
										position88, tokenIndex88 := p.position, p.tokenIndex
										{
											position90, tokenIndex90 := p.position, p.tokenIndex
											if p.buffer[p.position] != rune('^') {
												goto l91
											}
											p.position++
											if !p.rules[ruleRanges]() {
												goto l91
											}
											{
												p.add(ruleAction24, p.position)
											}
											goto l90
										l91:
											p.position, p.tokenIndex = position90, tokenIndex90
											if !p.rules[ruleRanges]() {
												goto l88
											}
										}
									l90:
										goto l89
									l88:
										p.position, p.tokenIndex = position88, tokenIndex88
									}
								l89:
									if p.buffer[p.position] != rune(']') {
										goto l70
									}
									p.position++
								}
							l81:
								if !p.rules[ruleSpacing]() {
									goto l70
								}
								p.add(ruleClass, position80)
							}
						case '"', '\'':
							{
								position93 := p.position
								{
									position94, tokenIndex94 := p.position, p.tokenIndex
									if p.buffer[p.position] != rune('\'') {
										goto l95
									}
									p.position++
									{
										position96, tokenIndex96 := p.position, p.tokenIndex
										{
											position98, tokenIndex98 := p.position, p.tokenIndex
											if p.buffer[p.position] != rune('\'') {
												goto l98
											}
											p.position++
											goto l96
										l98:
											p.position, p.tokenIndex = position98, tokenIndex98
										}
										if !p.rules[ruleChar]() {
											goto l96
										}
										goto l97
									l96:
										p.position, p.tokenIndex = position96, tokenIndex96
									}
								l97:
								l99:
									{
										position100, tokenIndex100 := p.position, p.tokenIndex
										{
											position101, tokenIndex101 := p.position, p.tokenIndex
											if p.buffer[p.position] != rune('\'') {
												goto l101
											}
											p.position++
											goto l100
										l101:
											p.position, p.tokenIndex = position101, tokenIndex101
										}
										if !p.rules[ruleChar]() {
											goto l100
										}
										{
											p.add(ruleAction21, p.position)
										}
										goto l99
									l100:
										p.position, p.tokenIndex = position100, tokenIndex100
									}
									if p.buffer[p.position] != rune('\'') {
										goto l95
									}
									p.position++
									if !p.rules[ruleSpacing]() {
										goto l95
									}
									goto l94
								l95:
									p.position, p.tokenIndex = position94, tokenIndex94
									if p.buffer[p.position] != rune('"') {
										goto l70
									}
									p.position++
									{
										position103, tokenIndex103 := p.position, p.tokenIndex
										{
											position105, tokenIndex105 := p.position, p.tokenIndex
											if p.buffer[p.position] != rune('"') {
												goto l105
											}
											p.position++
											goto l103
										l105:
											p.position, p.tokenIndex = position105, tokenIndex105
										}
										if !p.rules[ruleDoubleChar]() {
											goto l103
										}
										goto l104
									l103:
										p.position, p.tokenIndex = position103, tokenIndex103
									}
								l104:
								l106:
									{
										position107, tokenIndex107 := p.position, p.tokenIndex
										{
											position108, tokenIndex108 := p.position, p.tokenIndex
											if p.buffer[p.position] != rune('"') {
												goto l108
											}
											p.position++
											goto l107
										l108:
											p.position, p.tokenIndex = position108, tokenIndex108
										}
										if !p.rules[ruleDoubleChar]() {
											goto l107
										}
										{
											p.add(ruleAction22, p.position)
										}
										goto l106
									l107:
										p.position, p.tokenIndex = position107, tokenIndex107
									}
									if p.buffer[p.position] != rune('"') {
										goto l70
									}
									p.position++
									if !p.rules[ruleSpacing]() {
										goto l70
									}
								}
							l94:
								p.add(ruleLiteral, position93)
							}
						case '(':
							{
								position110 := p.position
								if p.buffer[p.position] != rune('(') {
									goto l70
								}
								p.position++
								if !p.rules[ruleSpacing]() {
									goto l70
								}
								p.add(ruleOpen, position110)
							}
							if !p.rules[ruleExpression]() {
								goto l70
							}
							{
								position111 := p.position
								if p.buffer[p.position] != rune(')') {
									goto l70
								}
								p.position++
								if !p.rules[ruleSpacing]() {
									goto l70
								}
								p.add(ruleClose, position111)
							}
						default:
							if !p.rules[ruleIdentifier]() {
								goto l70
							}
							{
								position112, tokenIndex112 := p.position, p.tokenIndex
								if !p.rules[ruleLeftArrow]() {
									goto l112
								}
								goto l70
							l112:
								p.position, p.tokenIndex = position112, tokenIndex112
							}
							{
								p.add(ruleAction17, p.position)
							}
						}
					}

					p.add(rulePrimary, position72)
				}
				{
					position114, tokenIndex114 := p.position, p.tokenIndex
					{
						switch p.buffer[p.position] {
						case '+':
							{
								position117 := p.position
								if p.buffer[p.position] != rune('+') {
									goto l114
								}
								p.position++
								if !p.rules[ruleSpacing]() {
									goto l114
								}
								p.add(rulePlus, position117)
							}
							{
								p.add(ruleAction16, p.position)
							}
						case '*':
							{
								position119 := p.position
								if p.buffer[p.position] != rune('*') {
									goto l114
								}
								p.position++
								if !p.rules[ruleSpacing]() {
									goto l114
								}
								p.add(ruleStar, position119)
							}
							{
								p.add(ruleAction15, p.position)
							}
						default:
							{
								position121 := p.position
								if p.buffer[p.position] != rune('?') {
									goto l114
								}
								p.position++
								if !p.rules[ruleSpacing]() {
									goto l114
								}
								p.add(ruleQuestion, position121)
							}
							{
								p.add(ruleAction14, p.position)
							}
						}
					}

					goto l115
				l114:
					p.position, p.tokenIndex = position114, tokenIndex114
				}
			l115:
				p.add(ruleSuffix, position71)
			}
			return true
		l70:
			p.position, p.tokenIndex = position70, tokenIndex70
			return false
		},
		/* 10 Primary <- <((&('<') (Begin Expression End Action20)) | (&('{') (Action Action19)) | (&('.') (Dot Action18)) | (&('[') Class) | (&('"' | '\'') Literal) | (&('(') (Open Expression Close)) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') (Identifier !LeftArrow Action17)))> */
		nil,
		/* 11 Identifier <- <(<(IdentStart IdentCont*)> Spacing)> */
		func() bool {
			position124, tokenIndex124 := p.position, p.tokenIndex
			{
				position125 := p.position
				{
					position126 := p.position
					if !p.rules[ruleIdentStart]() {
						goto l124
					}
				l127:
					{
						position128, tokenIndex128 := p.position, p.tokenIndex
						{
							position129 := p.position
							{
								position130, tokenIndex130 := p.position, p.tokenIndex
								if !p.rules[ruleIdentStart]() {
									goto l131
								}
								goto l130
							l131:
								p.position, p.tokenIndex = position130, tokenIndex130
								if c := p.buffer[p.position]; c < rune('0') || c > rune('9') {
									goto l128
								}
								p.position++
							}
						l130:
							p.add(ruleIdentCont, position129)
						}
						goto l127
					l128:
						p.position, p.tokenIndex = position128, tokenIndex128
					}
					p.add(rulePegText, position126)
				}
				if !p.rules[ruleSpacing]() {
					goto l124
				}
				p.add(ruleIdentifier, position125)
			}
			return true
		l124:
			p.position, p.tokenIndex = position124, tokenIndex124
			return false
		},
		/* 12 IdentStart <- <((&('_') '_') | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))> */
		func() bool {
			position132, tokenIndex132 := p.position, p.tokenIndex
			{
				position133 := p.position
				{
					switch p.buffer[p.position] {
					case '_':
						if p.buffer[p.position] != rune('_') {
							goto l132
						}
						p.position++
					case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
						if c := p.buffer[p.position]; c < rune('A') || c > rune('Z') {
							goto l132
						}
						p.position++
					default:
						if c := p.buffer[p.position]; c < rune('a') || c > rune('z') {
							goto l132
						}
						p.position++
					}
				}

				p.add(ruleIdentStart, position133)
			}
			return true
		l132:
			p.position, p.tokenIndex = position132, tokenIndex132
			return false
		},
		/* 13 IdentCont <- <(IdentStart / [0-9])> */
		nil,
		/* 14 Literal <- <(('\'' (!'\'' Char)? (!'\'' Char Action21)* '\'' Spacing) / ('"' (!'"' DoubleChar)? (!'"' DoubleChar Action22)* '"' Spacing))> */
		nil,
		/* 15 Class <- <((('[' '[' (('^' DoubleRanges Action23) / DoubleRanges)? (']' ']')) / ('[' (('^' Ranges Action24) / Ranges)? ']')) Spacing)> */
		nil,
		/* 16 Ranges <- <(!']' Range (!']' Range Action25)*)> */
		func() bool {
			position138, tokenIndex138 := p.position, p.tokenIndex
			{
				position139 := p.position
				{
					position140, tokenIndex140 := p.position, p.tokenIndex
					if p.buffer[p.position] != rune(']') {
						goto l140
					}
					p.position++
					goto l138
				l140:
					p.position, p.tokenIndex = position140, tokenIndex140
				}
				if !p.rules[ruleRange]() {
					goto l138
				}
			l141:
				{
					position142, tokenIndex142 := p.position, p.tokenIndex
					{
						position143, tokenIndex143 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune(']') {
							goto l143
						}
						p.position++
						goto l142
					l143:
						p.position, p.tokenIndex = position143, tokenIndex143
					}
					if !p.rules[ruleRange]() {
						goto l142
					}
					{
						p.add(ruleAction25, p.position)
					}
					goto l141
				l142:
					p.position, p.tokenIndex = position142, tokenIndex142
				}
				p.add(ruleRanges, position139)
			}
			return true
		l138:
			p.position, p.tokenIndex = position138, tokenIndex138
			return false
		},
		/* 17 DoubleRanges <- <(!(']' ']') DoubleRange (!(']' ']') DoubleRange Action26)*)> */
		func() bool {
			position145, tokenIndex145 := p.position, p.tokenIndex
			{
				position146 := p.position
				{
					position147, tokenIndex147 := p.position, p.tokenIndex
					if p.buffer[p.position] != rune(']') {
						goto l147
					}
					p.position++
					if p.buffer[p.position] != rune(']') {
						goto l147
					}
					p.position++
					goto l145
				l147:
					p.position, p.tokenIndex = position147, tokenIndex147
				}
				if !p.rules[ruleDoubleRange]() {
					goto l145
				}
			l148:
				{
					position149, tokenIndex149 := p.position, p.tokenIndex
					{
						position150, tokenIndex150 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune(']') {
							goto l150
						}
						p.position++
						if p.buffer[p.position] != rune(']') {
							goto l150
						}
						p.position++
						goto l149
					l150:
						p.position, p.tokenIndex = position150, tokenIndex150
					}
					if !p.rules[ruleDoubleRange]() {
						goto l149
					}
					{
						p.add(ruleAction26, p.position)
					}
					goto l148
				l149:
					p.position, p.tokenIndex = position149, tokenIndex149
				}
				p.add(ruleDoubleRanges, position146)
			}
			return true
		l145:
			p.position, p.tokenIndex = position145, tokenIndex145
			return false
		},
		/* 18 Range <- <((Char '-' Char Action27) / Char)> */
		func() bool {
			position152, tokenIndex152 := p.position, p.tokenIndex
			{
				position153 := p.position
				{
					position154, tokenIndex154 := p.position, p.tokenIndex
					if !p.rules[ruleChar]() {
						goto l155
					}
					if p.buffer[p.position] != rune('-') {
						goto l155
					}
					p.position++
					if !p.rules[ruleChar]() {
						goto l155
					}
					{
						p.add(ruleAction27, p.position)
					}
					goto l154
				l155:
					p.position, p.tokenIndex = position154, tokenIndex154
					if !p.rules[ruleChar]() {
						goto l152
					}
				}
			l154:
				p.add(ruleRange, position153)
			}
			return true
		l152:
			p.position, p.tokenIndex = position152, tokenIndex152
			return false
		},
		/* 19 DoubleRange <- <((Char '-' Char Action28) / DoubleChar)> */
		func() bool {
			position157, tokenIndex157 := p.position, p.tokenIndex
			{
				position158 := p.position
				{
					position159, tokenIndex159 := p.position, p.tokenIndex
					if !p.rules[ruleChar]() {
						goto l160
					}
					if p.buffer[p.position] != rune('-') {
						goto l160
					}
					p.position++
					if !p.rules[ruleChar]() {
						goto l160
					}
					{
						p.add(ruleAction28, p.position)
					}
					goto l159
				l160:
					p.position, p.tokenIndex = position159, tokenIndex159
					if !p.rules[ruleDoubleChar]() {
						goto l157
					}
				}
			l159:
				p.add(ruleDoubleRange, position158)
			}
			return true
		l157:
			p.position, p.tokenIndex = position157, tokenIndex157
			return false
		},
		/* 20 Char <- <(Escape / (!'\\' <.> Action29))> */
		func() bool {
			position162, tokenIndex162 := p.position, p.tokenIndex
			{
				position163 := p.position
				{
					position164, tokenIndex164 := p.position, p.tokenIndex
					if !p.rules[ruleEscape]() {
						goto l165
					}
					goto l164
				l165:
					p.position, p.tokenIndex = position164, tokenIndex164
					{
						position166, tokenIndex166 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('\\') {
							goto l166
						}
						p.position++
						goto l162
					l166:
						p.position, p.tokenIndex = position166, tokenIndex166
					}
					{
						position167 := p.position
						if !p.matchDot() {
							goto l162
						}
						p.add(rulePegText, position167)
					}
					{
						p.add(ruleAction29, p.position)
					}
				}
			l164:
				p.add(ruleChar, position163)
			}
			return true
		l162:
			p.position, p.tokenIndex = position162, tokenIndex162
			return false
		},
		/* 21 DoubleChar <- <(Escape / (<([a-z] / [A-Z])> Action30) / (!'\\' <.> Action31))> */
		func() bool {
			position169, tokenIndex169 := p.position, p.tokenIndex
			{
				position170 := p.position
				{
					position171, tokenIndex171 := p.position, p.tokenIndex
					if !p.rules[ruleEscape]() {
						goto l172
					}
					goto l171
				l172:
					p.position, p.tokenIndex = position171, tokenIndex171
					{
						position174 := p.position
						{
							position175, tokenIndex175 := p.position, p.tokenIndex
							if c := p.buffer[p.position]; c < rune('a') || c > rune('z') {
								goto l176
							}
							p.position++
							goto l175
						l176:
							p.position, p.tokenIndex = position175, tokenIndex175
							if c := p.buffer[p.position]; c < rune('A') || c > rune('Z') {
								goto l173
							}
							p.position++
						}
					l175:
						p.add(rulePegText, position174)
					}
					{
						p.add(ruleAction30, p.position)
					}
					goto l171
				l173:
					p.position, p.tokenIndex = position171, tokenIndex171
					{
						position178, tokenIndex178 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('\\') {
							goto l178
						}
						p.position++
						goto l169
					l178:
						p.position, p.tokenIndex = position178, tokenIndex178
					}
					{
						position179 := p.position
						if !p.matchDot() {
							goto l169
						}
						p.add(rulePegText, position179)
					}
					{
						p.add(ruleAction31, p.position)
					}
				}
			l171:
				p.add(ruleDoubleChar, position170)
			}
			return true
		l169:
			p.position, p.tokenIndex = position169, tokenIndex169
			return false
		},
		/* 22 Escape <- <(('\\' ('a' / 'A') Action32) / ('\\' ('b' / 'B') Action33) / ('\\' ('e' / 'E') Action34) / ('\\' ('f' / 'F') Action35) / ('\\' ('n' / 'N') Action36) / ('\\' ('r' / 'R') Action37) / ('\\' ('t' / 'T') Action38) / ('\\' ('v' / 'V') Action39) / ('\\' '\'' Action40) / ('\\' '"' Action41) / ('\\' '[' Action42) / ('\\' ']' Action43) / ('\\' '-' Action44) / ('\\' ('0' ('x' / 'X')) <((&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))+> Action45) / ('\\' <([0-3] [0-7] [0-7])> Action46) / ('\\' <([0-7] [0-7]?)> Action47) / ('\\' '\\' Action48))> */
		func() bool {
			position181, tokenIndex181 := p.position, p.tokenIndex
			{
				position182 := p.position
				{
					position183, tokenIndex183 := p.position, p.tokenIndex
					if p.buffer[p.position] != rune('\\') {
						goto l184
					}
					p.position++
					{
						position185, tokenIndex185 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('a') {
							goto l186
						}
						p.position++
						goto l185
					l186:
						p.position, p.tokenIndex = position185, tokenIndex185
						if p.buffer[p.position] != rune('A') {
							goto l184
						}
						p.position++
					}
				l185:
					{
						p.add(ruleAction32, p.position)
					}
					goto l183
				l184:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l188
					}
					p.position++
					{
						position189, tokenIndex189 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('b') {
							goto l190
						}
						p.position++
						goto l189
					l190:
						p.position, p.tokenIndex = position189, tokenIndex189
						if p.buffer[p.position] != rune('B') {
							goto l188
						}
						p.position++
					}
				l189:
					{
						p.add(ruleAction33, p.position)
					}
					goto l183
				l188:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l192
					}
					p.position++
					{
						position193, tokenIndex193 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('e') {
							goto l194
						}
						p.position++
						goto l193
					l194:
						p.position, p.tokenIndex = position193, tokenIndex193
						if p.buffer[p.position] != rune('E') {
							goto l192
						}
						p.position++
					}
				l193:
					{
						p.add(ruleAction34, p.position)
					}
					goto l183
				l192:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l196
					}
					p.position++
					{
						position197, tokenIndex197 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('f') {
							goto l198
						}
						p.position++
						goto l197
					l198:
						p.position, p.tokenIndex = position197, tokenIndex197
						if p.buffer[p.position] != rune('F') {
							goto l196
						}
						p.position++
					}
				l197:
					{
						p.add(ruleAction35, p.position)
					}
					goto l183
				l196:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l200
					}
					p.position++
					{
						position201, tokenIndex201 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('n') {
							goto l202
						}
						p.position++
						goto l201
					l202:
						p.position, p.tokenIndex = position201, tokenIndex201
						if p.buffer[p.position] != rune('N') {
							goto l200
						}
						p.position++
					}
				l201:
					{
						p.add(ruleAction36, p.position)
					}
					goto l183
				l200:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l204
					}
					p.position++
					{
						position205, tokenIndex205 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('r') {
							goto l206
						}
						p.position++
						goto l205
					l206:
						p.position, p.tokenIndex = position205, tokenIndex205
						if p.buffer[p.position] != rune('R') {
							goto l204
						}
						p.position++
					}
				l205:
					{
						p.add(ruleAction37, p.position)
					}
					goto l183
				l204:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l208
					}
					p.position++
					{
						position209, tokenIndex209 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('t') {
							goto l210
						}
						p.position++
						goto l209
					l210:
						p.position, p.tokenIndex = position209, tokenIndex209
						if p.buffer[p.position] != rune('T') {
							goto l208
						}
						p.position++
					}
				l209:
					{
						p.add(ruleAction38, p.position)
					}
					goto l183
				l208:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l212
					}
					p.position++
					{
						position213, tokenIndex213 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('v') {
							goto l214
						}
						p.position++
						goto l213
					l214:
						p.position, p.tokenIndex = position213, tokenIndex213
						if p.buffer[p.position] != rune('V') {
							goto l212
						}
						p.position++
					}
				l213:
					{
						p.add(ruleAction39, p.position)
					}
					goto l183
				l212:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l216
					}
					p.position++
					if p.buffer[p.position] != rune('\'') {
						goto l216
					}
					p.position++
					{
						p.add(ruleAction40, p.position)
					}
					goto l183
				l216:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l218
					}
					p.position++
					if p.buffer[p.position] != rune('"') {
						goto l218
					}
					p.position++
					{
						p.add(ruleAction41, p.position)
					}
					goto l183
				l218:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l220
					}
					p.position++
					if p.buffer[p.position] != rune('[') {
						goto l220
					}
					p.position++
					{
						p.add(ruleAction42, p.position)
					}
					goto l183
				l220:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l222
					}
					p.position++
					if p.buffer[p.position] != rune(']') {
						goto l222
					}
					p.position++
					{
						p.add(ruleAction43, p.position)
					}
					goto l183
				l222:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l224
					}
					p.position++
					if p.buffer[p.position] != rune('-') {
						goto l224
					}
					p.position++
					{
						p.add(ruleAction44, p.position)
					}
					goto l183
				l224:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l226
					}
					p.position++
					if p.buffer[p.position] != rune('0') {
						goto l226
					}
					p.position++
					{
						position227, tokenIndex227 := p.position, p.tokenIndex
						if p.buffer[p.position] != rune('x') {
							goto l228
						}
						p.position++
						goto l227
					l228:
						p.position, p.tokenIndex = position227, tokenIndex227
						if p.buffer[p.position] != rune('X') {
							goto l226
						}
						p.position++
					}
				l227:
					{
						position229 := p.position
						{
							switch p.buffer[p.position] {
							case 'A', 'B', 'C', 'D', 'E', 'F':
								if c := p.buffer[p.position]; c < rune('A') || c > rune('F') {
									goto l226
								}
								p.position++
							case 'a', 'b', 'c', 'd', 'e', 'f':
								if c := p.buffer[p.position]; c < rune('a') || c > rune('f') {
									goto l226
								}
								p.position++
							default:
								if c := p.buffer[p.position]; c < rune('0') || c > rune('9') {
									goto l226
								}
								p.position++
							}
						}

					l230:
						{
							position231, tokenIndex231 := p.position, p.tokenIndex
							{
								switch p.buffer[p.position] {
								case 'A', 'B', 'C', 'D', 'E', 'F':
									if c := p.buffer[p.position]; c < rune('A') || c > rune('F') {
										goto l231
									}
									p.position++
								case 'a', 'b', 'c', 'd', 'e', 'f':
									if c := p.buffer[p.position]; c < rune('a') || c > rune('f') {
										goto l231
									}
									p.position++
								default:
									if c := p.buffer[p.position]; c < rune('0') || c > rune('9') {
										goto l231
									}
									p.position++
								}
							}

							goto l230
						l231:
							p.position, p.tokenIndex = position231, tokenIndex231
						}
						p.add(rulePegText, position229)
					}
					{
						p.add(ruleAction45, p.position)
					}
					goto l183
				l226:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l235
					}
					p.position++
					{
						position236 := p.position
						if c := p.buffer[p.position]; c < rune('0') || c > rune('3') {
							goto l235
						}
						p.position++
						if c := p.buffer[p.position]; c < rune('0') || c > rune('7') {
							goto l235
						}
						p.position++
						if c := p.buffer[p.position]; c < rune('0') || c > rune('7') {
							goto l235
						}
						p.position++
						p.add(rulePegText, position236)
					}
					{
						p.add(ruleAction46, p.position)
					}
					goto l183
				l235:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l238
					}
					p.position++
					{
						position239 := p.position
						if c := p.buffer[p.position]; c < rune('0') || c > rune('7') {
							goto l238
						}
						p.position++
						{
							position240, tokenIndex240 := p.position, p.tokenIndex
							if c := p.buffer[p.position]; c < rune('0') || c > rune('7') {
								goto l240
							}
							p.position++
							goto l241
						l240:
							p.position, p.tokenIndex = position240, tokenIndex240
						}
					l241:
						p.add(rulePegText, position239)
					}
					{
						p.add(ruleAction47, p.position)
					}
					goto l183
				l238:
					p.position, p.tokenIndex = position183, tokenIndex183
					if p.buffer[p.position] != rune('\\') {
						goto l181
					}
					p.position++
					if p.buffer[p.position] != rune('\\') {
						goto l181
					}
					p.position++
					{
						p.add(ruleAction48, p.position)
					}
				}
			l183:
				p.add(ruleEscape, position182)
			}
			return true
		l181:
			p.position, p.tokenIndex = position181, tokenIndex181
			return false
		},
		/* 23 LeftArrow <- <((('<' '-') / '←') Spacing)> */
		func() bool {
			position244, tokenIndex244 := p.position, p.tokenIndex
			{
				position245 := p.position
				{
					position246, tokenIndex246 := p.position, p.tokenIndex
					if p.buffer[p.position] != rune('<') {
						goto l247
					}
					p.position++
					if p.buffer[p.position] != rune('-') {
						goto l247
					}
					p.position++
					goto l246
				l247:
					p.position, p.tokenIndex = position246, tokenIndex246
					if p.buffer[p.position] != rune('←') {
						goto l244
					}
					p.position++
				}
			l246:
				if !p.rules[ruleSpacing]() {
					goto l244
				}
				p.add(ruleLeftArrow, position245)
			}
			return true
		l244:
			p.position, p.tokenIndex = position244, tokenIndex244
			return false
		},
		/* 24 Slash <- <('/' Spacing)> */
		func() bool {
			position248, tokenIndex248 := p.position, p.tokenIndex
			{
				position249 := p.position
				if p.buffer[p.position] != rune('/') {
					goto l248
				}
				p.position++
				if !p.rules[ruleSpacing]() {
					goto l248
				}
				p.add(ruleSlash, position249)
			}
			return true
		l248:
			p.position, p.tokenIndex = position248, tokenIndex248
			return false
		},
		/* 25 And <- <('&' Spacing)> */
		func() bool {
			position250, tokenIndex250 := p.position, p.tokenIndex
			{
				position251 := p.position
				if p.buffer[p.position] != rune('&') {
					goto l250
				}
				p.position++
				if !p.rules[ruleSpacing]() {
					goto l250
				}
				p.add(ruleAnd, position251)
			}
			return true
		l250:
			p.position, p.tokenIndex = position250, tokenIndex250
			return false
		},
		/* 26 Not <- <('!' Spacing)> */
		func() bool {
			position252, tokenIndex252 := p.position, p.tokenIndex
			{
				position253 := p.position
				if p.buffer[p.position] != rune('!') {
					goto l252
				}
				p.position++
				if !p.rules[ruleSpacing]() {
					goto l252
				}
				p.add(ruleNot, position253)
			}
			return true
		l252:
			p.position, p.tokenIndex = position252, tokenIndex252
			return false
		},
		/* 27 Question <- <('?' Spacing)> */
		nil,
		/* 28 Star <- <('*' Spacing)> */
		nil,
		/* 29 Plus <- <('+' Spacing)> */
		nil,
		/* 30 Open <- <('(' Spacing)> */
		nil,
		/* 31 Close <- <(')' Spacing)> */
		nil,
		/* 32 Dot <- <('.' Spacing)> */
		nil,
		/* 33 SpaceComment <- <(Space / Comment)> */
		func() bool {
			position260, tokenIndex260 := p.position, p.tokenIndex
			{
				position261 := p.position
				{
					position262, tokenIndex262 := p.position, p.tokenIndex
					{
						position264 := p.position
						{
							switch p.buffer[p.position] {
							case '\t':
								if p.buffer[p.position] != rune('\t') {
									goto l263
								}
								p.position++
							case ' ':
								if p.buffer[p.position] != rune(' ') {
									goto l263
								}
								p.position++
							default:
								if !p.rules[ruleEndOfLine]() {
									goto l263
								}
							}
						}

						p.add(ruleSpace, position264)
					}
					goto l262
				l263:
					p.position, p.tokenIndex = position262, tokenIndex262
					{
						position266 := p.position
						{
							position267, tokenIndex267 := p.position, p.tokenIndex
							if p.buffer[p.position] != rune('#') {
								goto l268
							}
							p.position++
							goto l267
						l268:
							p.position, p.tokenIndex = position267, tokenIndex267
							if p.buffer[p.position] != rune('/') {
								goto l260
							}
							p.position++
							if p.buffer[p.position] != rune('/') {
								goto l260
							}
							p.position++
						}
					l267:
					l269:
						{
							position270, tokenIndex270 := p.position, p.tokenIndex
							{
								position271, tokenIndex271 := p.position, p.tokenIndex
								if !p.rules[ruleEndOfLine]() {
									goto l271
								}
								goto l270
							l271:
								p.position, p.tokenIndex = position271, tokenIndex271
							}
							if !p.matchDot() {
								goto l270
							}
							goto l269
						l270:
							p.position, p.tokenIndex = position270, tokenIndex270
						}
						if !p.rules[ruleEndOfLine]() {
							goto l260
						}
						p.add(ruleComment, position266)
					}
				}
			l262:
				p.add(ruleSpaceComment, position261)
			}
			return true
		l260:
			p.position, p.tokenIndex = position260, tokenIndex260
			return false
		},
		/* 34 Spacing <- <SpaceComment*> */
		func() bool {
			{
				position273 := p.position
			l274:
				{
					position275, tokenIndex275 := p.position, p.tokenIndex
					if !p.rules[ruleSpaceComment]() {
						goto l275
					}
					goto l274
				l275:
					p.position, p.tokenIndex = position275, tokenIndex275
				}
				p.add(ruleSpacing, position273)
			}
			return true
		},
		/* 35 MustSpacing <- <SpaceComment+> */
		func() bool {
			position276, tokenIndex276 := p.position, p.tokenIndex
			{
				position277 := p.position
				if !p.rules[ruleSpaceComment]() {
					goto l276
				}
			l278:
				{
					position279, tokenIndex279 := p.position, p.tokenIndex
					if !p.rules[ruleSpaceComment]() {
						goto l279
					}
					goto l278
				l279:
					p.position, p.tokenIndex = position279, tokenIndex279
				}
				p.add(ruleMustSpacing, position277)
			}
			return true
		l276:
			p.position, p.tokenIndex = position276, tokenIndex276
			return false
		},
		/* 36 Comment <- <(('#' / ('/' '/')) (!EndOfLine .)* EndOfLine)> */
		nil,
		/* 37 Space <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') EndOfLine))> */
		nil,
		/* 38 EndOfLine <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position282, tokenIndex282 := p.position, p.tokenIndex
			{
				position283 := p.position
				{
					position284, tokenIndex284 := p.position, p.tokenIndex
					if p.buffer[p.position] != rune('\r') {
						goto l285
					}
					p.position++
					if p.buffer[p.position] != rune('\n') {
						goto l285
					}
					p.position++
					goto l284
				l285:
					p.position, p.tokenIndex = position284, tokenIndex284
					if p.buffer[p.position] != rune('\n') {
						goto l286
					}
					p.position++
					goto l284
				l286:
					p.position, p.tokenIndex = position284, tokenIndex284
					if p.buffer[p.position] != rune('\r') {
						goto l282
					}
					p.position++
				}
			l284:
				p.add(ruleEndOfLine, position283)
			}
			return true
		l282:
			p.position, p.tokenIndex = position282, tokenIndex282
			return false
		},
		/* 39 EndOfFile <- <!.> */
		nil,
		/* 40 Action <- <('{' <ActionBody*> '}' Spacing)> */
		func() bool {
			position288, tokenIndex288 := p.position, p.tokenIndex
			{
				position289 := p.position
				if p.buffer[p.position] != rune('{') {
					goto l288
				}
				p.position++
				{
					position290 := p.position
				l291:
					{
						position292, tokenIndex292 := p.position, p.tokenIndex
						if !p.rules[ruleActionBody]() {
							goto l292
						}
						goto l291
					l292:
						p.position, p.tokenIndex = position292, tokenIndex292
					}
					p.add(rulePegText, position290)
				}
				if p.buffer[p.position] != rune('}') {
					goto l288
				}
				p.position++
				if !p.rules[ruleSpacing]() {
					goto l288
				}
				p.add(ruleAction, position289)
			}
			return true
		l288:
			p.position, p.tokenIndex = position288, tokenIndex288
			return false
		},
		/* 41 ActionBody <- <((!('{' / '}') .) / ('{' ActionBody* '}'))> */
		func() bool {
			position293, tokenIndex293 := p.position, p.tokenIndex
			{
				position294 := p.position
				{
					position295, tokenIndex295 := p.position, p.tokenIndex
					{
						position297, tokenIndex297 := p.position, p.tokenIndex
						{
							position298, tokenIndex298 := p.position, p.tokenIndex
							if p.buffer[p.position] != rune('{') {
								goto l299
							}
							p.position++
							goto l298
						l299:
							p.position, p.tokenIndex = position298, tokenIndex298
							if p.buffer[p.position] != rune('}') {
								goto l297
							}
							p.position++
						}
					l298:
						goto l296
					l297:
						p.position, p.tokenIndex = position297, tokenIndex297
					}
					if !p.matchDot() {
						goto l296
					}
					goto l295
				l296:
					p.position, p.tokenIndex = position295, tokenIndex295
					if p.buffer[p.position] != rune('{') {
						goto l293
					}
					p.position++
				l300:
					{
						position301, tokenIndex301 := p.position, p.tokenIndex
						if !p.rules[ruleActionBody]() {
							goto l301
						}
						goto l300
					l301:
						p.position, p.tokenIndex = position301, tokenIndex301
					}
					if p.buffer[p.position] != rune('}') {
						goto l293
					}
					p.position++
				}
			l295:
				p.add(ruleActionBody, position294)
			}
			return true
		l293:
			p.position, p.tokenIndex = position293, tokenIndex293
			return false
		},
		/* 42 Begin <- <('<' Spacing)> */
		nil,
		/* 43 End <- <('>' Spacing)> */
		nil,
		/* 45 Action0 <- <{ p.AddPackage(text) }> */
		nil,
		/* 46 Action1 <- <{ p.AddPeg(text) }> */
		nil,
		/* 47 Action2 <- <{ p.AddState(text) }> */
		nil,
		nil,
		/* 49 Action3 <- <{ p.AddImport(text) }> */
		nil,
		/* 50 Action4 <- <{ p.AddRule(text) }> */
		nil,
		/* 51 Action5 <- <{ p.AddExpression() }> */
		nil,
		/* 52 Action6 <- <{ p.AddAlternate() }> */
		nil,
		/* 53 Action7 <- <{ p.AddNil(); p.AddAlternate() }> */
		nil,
		/* 54 Action8 <- <{ p.AddNil() }> */
		nil,
		/* 55 Action9 <- <{ p.AddSequence() }> */
		nil,
		/* 56 Action10 <- <{ p.AddPredicate(text) }> */
		nil,
		/* 57 Action11 <- <{ p.AddStateChange(text) }> */
		nil,
		/* 58 Action12 <- <{ p.AddPeekFor() }> */
		nil,
		/* 59 Action13 <- <{ p.AddPeekNot() }> */
		nil,
		/* 60 Action14 <- <{ p.AddQuery() }> */
		nil,
		/* 61 Action15 <- <{ p.AddStar() }> */
		nil,
		/* 62 Action16 <- <{ p.AddPlus() }> */
		nil,
		/* 63 Action17 <- <{ p.AddName(text) }> */
		nil,
		/* 64 Action18 <- <{ p.AddDot() }> */
		nil,
		/* 65 Action19 <- <{ p.AddAction(text) }> */
		nil,
		/* 66 Action20 <- <{ p.AddPush() }> */
		nil,
		/* 67 Action21 <- <{ p.AddSequence() }> */
		nil,
		/* 68 Action22 <- <{ p.AddSequence() }> */
		nil,
		/* 69 Action23 <- <{ p.AddPeekNot(); p.AddDot(); p.AddSequence() }> */
		nil,
		/* 70 Action24 <- <{ p.AddPeekNot(); p.AddDot(); p.AddSequence() }> */
		nil,
		/* 71 Action25 <- <{ p.AddAlternate() }> */
		nil,
		/* 72 Action26 <- <{ p.AddAlternate() }> */
		nil,
		/* 73 Action27 <- <{ p.AddRange() }> */
		nil,
		/* 74 Action28 <- <{ p.AddDoubleRange() }> */
		nil,
		/* 75 Action29 <- <{ p.AddCharacter(text) }> */
		nil,
		/* 76 Action30 <- <{ p.AddDoubleCharacter(text) }> */
		nil,
		/* 77 Action31 <- <{ p.AddCharacter(text) }> */
		nil,
		/* 78 Action32 <- <{ p.AddCharacter("\a") }> */
		nil,
		/* 79 Action33 <- <{ p.AddCharacter("\b") }> */
		nil,
		/* 80 Action34 <- <{ p.AddCharacter("\x1B") }> */
		nil,
		/* 81 Action35 <- <{ p.AddCharacter("\f") }> */
		nil,
		/* 82 Action36 <- <{ p.AddCharacter("\n") }> */
		nil,
		/* 83 Action37 <- <{ p.AddCharacter("\r") }> */
		nil,
		/* 84 Action38 <- <{ p.AddCharacter("\t") }> */
		nil,
		/* 85 Action39 <- <{ p.AddCharacter("\v") }> */
		nil,
		/* 86 Action40 <- <{ p.AddCharacter("'") }> */
		nil,
		/* 87 Action41 <- <{ p.AddCharacter("\"") }> */
		nil,
		/* 88 Action42 <- <{ p.AddCharacter("[") }> */
		nil,
		/* 89 Action43 <- <{ p.AddCharacter("]") }> */
		nil,
		/* 90 Action44 <- <{ p.AddCharacter("-") }> */
		nil,
		/* 91 Action45 <- <{ p.AddHexaCharacter(text) }> */
		nil,
		/* 92 Action46 <- <{ p.AddOctalCharacter(text) }> */
		nil,
		/* 93 Action47 <- <{ p.AddOctalCharacter(text) }> */
		nil,
		/* 94 Action48 <- <{ p.AddCharacter("\\") }> */
		nil,
	}

	return nil
}
